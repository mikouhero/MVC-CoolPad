# 跳表（SkipList）

假设有一个有序的链表，如果要从该链表中查找某一个数据，只能从头到尾的遍历查找，时间复杂度是O(n)

假设像下图这样 ，在原来的单链表上增加一级索引，每两个节点取一个节点到索引层，其中down 为指向下一级节点的指针

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c5ba3b8a83249bcbb39bd57cd710432~tplv-k3u1fbpfcp-watermark.image)

假设现在需要查找【16】这个节点，可以先遍历索引层节点，当遍历到【13】这个节点时，发现下一个节点为【17】，那么我们需要的节点【16】 肯定在中间，此时通过索引节点【13】的down 指针，下降到原始链表中继续遍历，此时只需要遍历两个节点就找到了我们需要的【16】。如果在原始链表中查找【16】，需要遍历10个节点，现在只需要遍历七个节点。

假设现在在原来的一级索引上边按同样的方法，在增加一层索引，如再查【16】这个节点，只需要遍历6个节点了。查找一个节点需要遍历的节点又减少了

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a05dc4f9e724b0c908174b6191eb4bc~tplv-k3u1fbpfcp-watermark.image)

https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a05dc4f9e724b0c908174b6191eb4bc~tplv-k3u1fbpfcp-watermark.image


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f67bd599adf4765bff0b37dbc598711~tplv-k3u1fbpfcp-watermark.image)

从图中可以看出，原来没有索引的时候，查找【62】这个节点需要遍历62个节点，现在只需要遍历11个节点，速度提高了很多。当链表的长度n比较大时，比如1000、10000的时候，在构建索引之后，查找效率的提升就会非常明显。`这种链表加多级索引的结构，就是跳表`


### 跳表的时间复杂度

 如果链表有n个节点，可以有多少级索引？
  
按照上边例子中的那种方式，每两个结点会抽出一个结点作为上一级索引的结点     
第1级索引的节点个数大约是 n/2       
第2级索引的节点个数大约是 n/2/2        
第3级索引的节点个数大约是 n/2/2/2       
第4级索引的节点个数大约是 n/2/2/2/2     
依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是 n/(2^k)

假设索引有h级，最高级的索引有2个结点。通过上面的公式，可以得到n/(2^h)=2，从而求得 h=log2n-1(2为底)。如果包含原始链表这一层，整个跳表的高度就是log2n(2为底)。`在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那在跳表中查询一个数据的时间复杂度就是O(m*logn)`


这个m的值是多少？按照上边的例子中这种索引结构，我们每一级索引都最多只需要遍历3个结点，也就是说m=3，解释一下为啥是3
假设要查找的数据是x，在第k级索引中，我们遍历到y结点之后，发现x大于y，小于后面的结点z，所以我们通过y的 down 指针，从第k级索引下降到第k-1 级索引。在第k-1级索引中，y和 z之间只有3个结点（包含 y 和 z），所以，我们在k-1级索引中最多只需要遍历3个结点，依次类推，每一级索引都最多只需要遍历3个结点

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e5798ddbc334b708e9aa2c72d6f5332~tplv-k3u1fbpfcp-watermark.image)               

通过上面的分析，得到m=3，所以在`跳表中查询任意数据的时间复杂度就是O(logn)`。这个查找的时间复杂度跟二分查找是一样的。换句话说，其实是基于单链表实现了二分查找。不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引，是一种空间换时间的思路

### 跳表的空间复杂度分析

假设原始链表大小为n，那第一级索引大约有n/2个结点，第二级索引大约有n/4个结点，以此类推，每上升一级就减少一半，直到剩下2个结点。如果我们把每层索引的结点数写出来，就是一个等比数列

这几级索引的结点总和就是n/2+n/4+n/8…+8+4+2=n-2。所以，`跳表的空间复杂度是 O(n)`。也就是说，如果将包含n个结点的单链表构造成跳表，我们需要额外再用接近n个结点的存储空间

- 如何降低索引占用的内存空间？

前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，就不用那么多索引结点了

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c7de5359299417aa7f4e5f7614cbfa3~tplv-k3u1fbpfcp-watermark.image)


从图中可以看出，第一级索引需要大约n/3个结点，第二级索引需要大约n/9个结点。每往上一级，索引结点个数都除以3。为了方便计算，假设最高一级的索引结点个数是1。我们把每级索引的结点个数都写下来，也是一个等比数列

通过等比数列求和公式，总的索引结点大约就是n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引节点存储空间

实际上，在平时开发中，不必太在意索引占用的额外空间。在数据结构和算法中，习惯性地把要处理的数据看成`整数`，但是在实际的开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要`储关键值`和几个指针，并不需要存储对象，`所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了`


### 跳表的操作


-  插入

在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，为了保证原始链表中数据的有序性，需要先找到要插入的位置，这个查找操作就会比较耗时
对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，查找某个节点的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是O(logn)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a6494c6b8df43ccae507aa9e6860ccf~tplv-k3u1fbpfcp-watermark.image)

- 删除

`如果要删除的结点在索引中有出现，除了要删除原始链表中的结点，还要删除索引中的`。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果用的是双向链表，就不需要考虑这个问题了

- 索引动态更新

当不停地往跳表中插入数据时，如果不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/035845c12a984f549ba465bc1186117f~tplv-k3u1fbpfcp-watermark.image)

作为一种动态数据结构，它需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降

当我们往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层，就是`随机函数`要干的事情

通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值K，那就将这个结点添加到`第一级到第K级`这K级索引中

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/824fa84ad278408a8ee0b76afc3026bd~tplv-k3u1fbpfcp-watermark.image)
