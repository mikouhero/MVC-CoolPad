# Trie 字典树

字典树不是二叉树 和它的名字一样，首先来看他的节点结构(`根节点是不包含字符的，根节点的c是空`)

```c
class Node{
    char c;//当前节点的字符
    Node[] next;//当前节点的下一个节点
    boolean end;//判断这个字母是不是一个结尾
}

```

![](https://user-gold-cdn.xitu.io/2019/5/30/16b07dd93b522348)

### 字典树的作用

可以看到上面的图用深度优先中序遍历的话他每遍历到叶子节点都是一个单词，如and，as，at，cn，com。
在以前的电话簿系统中，如果这时我们用二分搜索树去保存每个联系人的信息，假设我们的通讯录有一千万个联系人信息，那么我们通过名字去查询这个联系人的信息是非常费时的O(logn)。而如果我们用字典树，比如我们要查询一个名叫and的联系人，我们通过根节点在next中找a，在a节点中找n，再在n节点中找b(如果这里全是英文字母那么next也只有26种情况)，这时我们的时间复杂度只和这个单词的长度有关O(K)，K为单词长度。那么可见这种情况下字典树的优势非常明显。当然，字典树的这种设计也就是典型的用空间换取时间的思路。


### 字典树的操作
字典树的操作主要为增，删，查

在开始之前，解释一下end的作用，例如我们有一个as和一个ass，我们如何判断ass这个单词是只有ass还是还有as这个单词呢？我们需要对每一个节点进行一个标识，标识这个单词是否在这里是一个完整的单词。例如ass，最后一个s中end就要为true，因为ass最后的s是ass的结尾。而如果还有个as单词，那么第一个s就要为true来代表as这个单词以s结束。


##### 增加

增加的逻辑就很简单了，例如增加一个geek

定位到头节点，判断next中是否有g，没有的话先构造节点g(所有新构造的节点end为false)，再加入到当前节点的next之中，然后移动到节点g
同理判断e，构造并定位到下一个节点，然后e，然后k
当移动到节点k时，代表单词插入到结尾了，就要设置end为true

##### 删除
例如上图中我们要删除an这个单词

通过头节点到达a，在达到n，如果n的next不为空，那么把n的end改为false即可
如果n的next为空，那么删掉n，回溯到上个节点删掉next中n这个值，再判断next之中是否为空，不空的话结束。空的话再删除a，结束。

##### 查找
例如现在我们要查找and

通过根节点的next找a，存在，当前节点换位a节点
判断a节点的next找n，存在，当前节点换位n节点
判断n节点的next找d，存在，当前节点换位d节点，这时要查找的单词到结尾了，再判断d的end是否为true，true的话表示找到，否则就是没找到。

