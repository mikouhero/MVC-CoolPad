# AVL 
AVL（平衡二叉树），它也是一种二分搜索树。它的特点是每个节点的左右子树之差不超过1。在某种特殊的情况下，普通的二分搜索树可能退化为链表，例如加入的元素顺序为1，2，3，4，5。这个时候查询的效率会从O(logn)退化为O(n)。而我们解决这种特定的情况就需要采用平衡二叉树来解决这个问题。


### AVL 的定义

AVL的每个节点的左子树小于(大于)该节点，右子树大于(小于)该节点，每个节点的左右子树的深度之差不超过1。节点的左右子树深度之差叫平衡因子。

### AVL的操作

增删改查操作和二分搜索树类似，但是要多考虑的就是对节点的平衡考虑，如果一串数字的插入顺序为3，4，5。那么这棵树结构就会退化为一个链表。而这时候AVL就会对这个树进行旋转操作来达到平衡，所以，我们就知道旋转的操作会在增加，删除，修改这三个地方进行旋转。旋转操作分为下面四种情况

##### LL右单旋转
![](https://user-gold-cdn.xitu.io/2019/6/4/16b22b34f2309a6f)

如图，8的左子树已经退化为链表，并且5，8这两个节点不再平衡，这时我们先找到深度最深的不平衡节点5，对节点5进行LL旋转操作，在如图的这种情况下，得到右图的结构

##### RR左单旋转
![](https://user-gold-cdn.xitu.io/2019/6/4/16b22b3571c2cbe0)

如图，当插入顺序为当插入顺序为8，3，10，13，15的时候，树的结构变成左边的样子，这时10节点和8节点已经不平衡，为了保持AVL的平衡，我们要对10节点进行RR旋转，如右图所示

##### LR先左后右

![](https://user-gold-cdn.xitu.io/2019/6/4/16b22b356a56512d)

如图。5，8节点已经不平衡，这时要对5节点做平衡处理，首先将5进行RR左旋转，7的左节点也变为5的右节点。

![](https://user-gold-cdn.xitu.io/2019/6/4/16b22b34f26233f5)

这时7，8还是不平衡的，对8进行右旋转，8的右节点也变为8的左节点，如图。

#####  RL先右后左

![](https://user-gold-cdn.xitu.io/2019/6/4/16b22b34fc33bebb)

如左图，8，13节点不平衡，对13节点进行LL右旋转，得到右图

![](https://user-gold-cdn.xitu.io/2019/6/4/16b22b34f144d0bc)
这时8，10是不平衡的，对8节点进行RR左旋转，得到右图。

以上就是保持平衡的方式


### 插入
插入操作和平衡二叉树类似，不过在插入之后要保持树的平衡，针对以上四种情况保持。
### 删除
删除操作和平衡二叉树类似，在删除的时候当把子节点移到删除节点位置后也可能对树进行旋转保持平衡。

AVL的增删改查的平均时间复杂度都是O(logn)，他比二分搜索树的好处在于他能够对树结构进行一个平衡，而不让他退化为链表

这里如何判断一个节点是否平衡呢？这里看一下AVL中每个节点的结构

```c
    private class Node{
        public K key;
        public V value;
        public Node left, right;
        public int height;//节点的当前高度
    }

```

判断一个节点是否平衡，即计算一个节点的平衡因子

```c 
    private int getBalanceFactor(Node node){
        if(node == null)
            return 0;
        //返回平衡因子，如果结果小于-1说明右倾；结果大于1说明左倾；结果在-1到1之间说明节点平衡
        return node.left.height - node.right.height;
    }

```
