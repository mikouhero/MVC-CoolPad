# slice

## 说明
> 1、切片是数组的引用 ，属于引用类型，但自身是结构体，值拷贝传递  
2 、切片长度可变   
3 、cap 可以求出slice 最大扩张容量，0 <= len(slice) <= len(array)，其中array是slice引用的数组  
4 、slice == nil  len 和cap 函数的结果都等于0   
5、当append 追加元素后，超了切片的cap值，就会重新分配了底层数组，并复制数据。如果只追加没超过 s.cap 限制，也就不会重新分配。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。    
6、a[x:y:z] 切片内容[x:y] len = y-x  cap =z-x




## 切片的本质 
切片的本质是对底层数组的封装: 底层数组的指针、切片的长度和切片的容量

![](https://www.liwenzhou.com/images/Go/slice/slice_01.png)

切片 s1 :=a[0:5]

切片 s2 := a[3:6]

![](https://www.liwenzhou.com/images/Go/slice/slice_02.png)



## 切片不能直接比较
- 切片之间不能比较，不能使用 == 操作符来判断两个切片之间是否包含全部相等元素
- 切片唯一合法的比较操作是和nil 比较
- 一个nil 值的切片并没有底层数组， 他的len = 0 ,cap = 0
- 但是一个len = 0 ,cap = 0的切片不一定是 nil 

## append() 方法为切片添加元素 
- 通过var 申明的零值切片可以在append()函数直接使用 无需初始化
- 每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在append()函数调用时，所以我们通常都需要用原变量接收append函数的返回值
