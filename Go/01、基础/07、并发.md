# 并发


### 进程和线程
>  进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位  
线程是进程的一个执行实体，是CPU  调度和分派的基本单位，它是比进程更小的能独立运行的基本单位  
一个进程可以创建和撤销多个线程 同一个进程中的多个线程可以并发执行 

### 并发和并行
> 多线程程序在一个核的CPU 上运行  就是`并发`
> 多线程程序在多个核的CPU上运行 就是 `并行`

### 协程和线程
> 协程：独立的栈空间，共享堆空间 调度由用户自己控制，本质上有点类似用户级线程 这些用户级线程的调度也是自己实现的   
>线程：一个线程上可以跑多个协程 协程就是轻量级的线程


### goroutine 只是由官方实现的超级线程池
每个4-5k的栈内存占用和由于实现机制而大幅减少的创建和销毁开销是go高并发的根本原因

### 并发不是并行
并发主要是由切换时间片来实现“同时”运行 并行则是直接利用多核实现线程的运行 go  可以设置使用核数 以发挥多核计算机的能力

### `goroutine奉行通过通信来共享内存 而不是共享内存来通信`


### 可增长的栈
OS线程（操作系统线程）一般都有固定的栈内存（通常2MB） 一个goroutine 的栈在其生命周期开始时只有很小的栈（典型情况下2KB）,goroutine的栈不是固定的 它可以按需增大和缩小 goroutine 的栈大小限制可以达到1GB ，虽然极少会用到这么大，所以go 语言中一次创建10W左右的goroutine 也是可以的

### goroutine 调度 
GPM 是go 语言运行时（runtime）层面的实现 是go语言自己实现的一套调度系统 区别于操作系统调度OS 线程 
- G => goroutine ,除了存放当前goroutine信息外 还有与所在P的绑定信息  
- P管理着一组goroutine队列 ，p里面会存储当前goroutine 运行的上下文环境（函数指针，堆栈地址以及地址边界），p会对自己管理的goroutine队列做一些调度  （比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。
- M(machine) 是go 运行时（runtime）对系统内核操作线程的虚拟 M与内核线程一般是一一映射的关系 一个线程最早是要放在M上执行的

`P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M`
