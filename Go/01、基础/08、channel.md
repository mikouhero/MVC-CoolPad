# channel


- 关闭通道  

关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。
> 1.对一个关闭的通道再发送值就会导致panic。  
    2.对一个关闭的通道进行接收会一直获取值直到通道为空 。  
    3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 
    4.关闭一个已经关闭的通道会导致panic 
    
    
    ```golang
      
      ch := nake(chan int )
      ch<-10
      // 编译成功 执行失败  fatal error: all goroutines are asleep - deadlock!
      
      
      /**
      ch := make(chan int)创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。
      
       启用一个goroutine 去接收值
      
      */
      
    ```
    
无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。 

使用无缓冲通道进行通信将导致发送和接收的goroutine同步化。因此，无缓冲通道也被称为同步通道



