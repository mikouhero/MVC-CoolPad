# 索引类型


### 主键唯一索引
主键索引的叶子节点存的是整行数据信息。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。主键自增是无法保证完全自增的哦，遇到唯一键冲突、事务回滚等都可能导致不连续。

主键推荐用自增id，而不是uuid。上面的聚簇索引说到每页数据都是排序的，并且页之间也是排序的，如果是uuid，那么其肯定是随机的，其可能从中间插入，导致页的分裂，产生很多表碎片。如果是自增的，那么其有从小到大自增的，有顺序，那么在插入的时候就添加到当前索引的后续位置。当一页写满，就会自动开辟一个新的页。


### 唯一索引
以唯一列生成的索引，该列不允许有重复值，但允许有空值(NULL)

### 普通索引
最基本的索引，没有任何限制，是我们大多数情况下使用到的索引。

`普通索引跟唯一索引查询性能`:    
InnoDB的数据是按数据页为单位来读写的，默认每页16KB，因此这两种索引查询数据性能差别微乎其微。

### 联合索引
- 相对单列索引，组合索引是用多个列组合构建的索引，一次性最多联合16个，使用最左匹配原则。    
- 对于联合索引来说，如果存在范围查询，比如 between,>,< 等条件时，会造成后面的索引字段失效


### 最左前缀原则
- 对多个字段同时建立的组合索引(有顺序，ABC，ACB是完全不同的两种联合索引) 以联合索引(a,b,c)为例，建立这样的索引相当于建立了索引a、ab、abc三个索引。另外组合索引实际还是一个索引，并非真的创建了多个索引，只是产生的
效果等价于产生多个索引。
- 全值匹配的时候优化器会改变顺序，也就是说你全值匹配时的顺序和原先的联合索引顺序不一致没有关系，优化器会帮你调好。
- 遇到范围匹配会取消索引。比如这个时候你进行一个这样的 select 操作
第一原则是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
> 如有索引(a, b, c, d)，查询条件a = 1 and b = 2 and c > 3 and d = 4，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是相等的情况，不能是范围匹配)


### 覆盖索引
一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。        
覆盖索引就是把要查询出的列和索引是对应的，不做回表操作     

>现在我创建了索引(username,age)，在查询数据的时候：select username , age from user where username = '张三' and age = 20。    
>很明显地知道，我们上边的查询是走索引的，并且，要查询出的列在叶子节点都存在！所以，就不用回表了~   
>所以，能使用覆盖索引就尽量使用吧~  

### 回表
先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树。


### 索引下推

在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段值。       
MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
```mysql
  select * from stu where class > 100 and name = '张三';
  // class 和name 是联合索引
```
> 因为刚刚的最左匹配原则我们放弃了索引，后面我们紧接着会通过回表进行判断 name，这个时候我们所要做的操作应该是这样的

![](https://cdn.learnku.com/uploads/images/202003/25/32535/eCMgvNTLAY.png)
但是有了索引下推之后就变成这样了，此时 “李四” 和 “小明” 这两个不会再进行回表。

![](https://cdn.learnku.com/uploads/images/202003/25/32535/zENzPvX7FH.png)



