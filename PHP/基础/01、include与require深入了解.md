# include/require深入了解


### include  
先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 include_path 指定的目录寻找。  
如果在 include_path 下没找到该文件则 include 最后才在调用脚本文件所在的目录和当前工作目录下寻找。  
如果最后仍未找到文件则 include 结构会发出一条警告；这一点和 require 不同，后者会发出一个致命错误。  
如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 \ 开头，在 Unix/Linux 下以 / 开头）还是当前目录的相对路径（以 . 或者 .. 开头）——include_path 都会被完全忽略。  

### require
require 和 include 几乎完全一样，除了处理失败的方式不同之外。  
require 在出错时产生 E_COMPILE_ERROR 级别的错误。  
换句话说将导致脚本中止而 include 只产生警告（E_WARNING），脚本会继续运行。  

### PHP中的include_path
PHP在遇到require(_once)/include(_once)的指令的时候, 首先会做如下的判断:

是否为绝对路径？   
    - 是 ， 则直接包含，并结束。  
    - 否， 进入另一个逻辑   
 (经过多次调用，宏展开后进入_php_stream_fopen_with_path)寻找此文件)
接下来, 在_php_stream_fopen_with_path中, 会做如下判断:  

要包含的文件路径是相对路径么(形如./file, ../dir/file, 以下用”目录相对路径代替”)?  
    - 是, 则跳过include_path的作用逻辑, 直接解析相对路径。
    
`结论最好的使用绝对路径`
> 因为使用include_path和相对路径的情况下, 性能会和寻找的次数有关, 最坏的情况下, 如果你有10个include_path, 那么最多可能会重试11次才能找到要包含的文件, 所以, 在能使用绝对路径的情况下最好使用绝对路径.  
因为目录相对路径的basedir, 永远都是当前工作路径, 如果要使用, 需要和实际部署路径相关, 所以实际使用的很少(当然, 也有借助chdir来完成的模块).  
在模块化的系统设计中, 一般应该在模块内, 通过获取模块的部署路径(dirname(FILE), php5.3以后更是提供了DIR常量)从而使用绝对路径.
  
  
#### include():

1. include引入文件的时候，如果碰到错误，会给出提示(Warning)，并继续运行下边的代码。
2. 在执行文件时每次都要进行读取和评估
3. 一般是放在流程控制的处理区段中
4. PHP脚本文件在读到include()语句时，才将它包含的文件读取进来
5. include()是有条件包含函数
#### require():
1. require引入文件的时候，如果碰到错误，会给出提示(Fatal error)，并停止运行下边的代码。
2. 文件只处理一次（实际上，文件内容替换require()语句）
3. 通常放在PHP脚本程序的最前面
4. PHP程序在执行前，就会先读入require()语句所引入的文件，使它变成PHP脚本文件的一部分。
5. require()则是无条件包含函数

结论
incluce在用到时加载
require在一开始就加载
_once后缀表示已加载的不加载
如果可能执行多次的代码，则使用require()效率比较高
如果每次执行代码时是读取不同的文件，或者有通过一组文件迭代的循环，就使用include()语句