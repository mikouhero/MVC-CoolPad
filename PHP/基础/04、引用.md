# 引用 

### 变量的引用

```php 

$a="ABC"; 
$b =&$a; 
echo $a;//这里输出:ABC 
echo $b;//这里输出:ABC 
$b="EFG"; 
echo $a;//这里$a的值变为EFG 所以输出EFG echo $b;//这里输出EFG 

```

### 函数的引用返回

```php
function &test(){ 
    static $b=0;//申明一个静态变量 
    $b=$b+1; 
    echo $b; 
    return $b; 
}
$a=test();//这条语句会输出　$b的值　为１ 
$a=5; $a=test();//这条语句会输出　$b的值　为2
$a=&test();//这条语句会输出　$b的值　为3 
$a=5; $a=test();//这条语句会输出　$b的值　为6

```

- 通过这种方式$a=test();得到的其实不是函数的引用返回，这跟普通的函数调用没有区别。    
- 至于原因：这是ＰＨＰ的规定 ＰＨＰ规定通过$a=&test(); 方式得到的才是函数的引用返回 至于什么是引用返回呢（ＰＨＰ手册上说：引用返回用在当想用函数找到引用应该被绑定在哪一个变量上面时。)   
 - 用上面的例子来解释就是 $a=test()方式调用函数，只是将函数的值赋给$a而已，　而$a做任何改变，都不会影响到函数中的$b   
 - 通过$a=&test()方式调用函数呢, 他的作用是将return $b中的　$b变量的内存地址与$a变量的内存地址　指向了同一个地方 即产生了相当于这样的效果($a=&b;) 所以改变$a的值　也同时改变了$b的值　所以在执行了 $a=&test(); $a=5; 以后，$b的值变为了5
 

### 对象的引用 
```php 

class a {
    public  $abc =  'ABC';
}
$b  = new a;
$c = $b;

echo $b->abc;//这里输出ABC
echo $c->abc;//这里输出ABC
$b->abc="DEF";
echo $c->abc;//这里输出DEF
```
- `在php5+ 中对象的复制是通过引用实现的`
>列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&$b;  
 PHP5中默认就是通过引用来调用对象，但有时你可能想建立一个对象的副本，并希望原来的对象的改变不影响到副本 .  
 为了这样的目的，PHP定义了一个特殊的方法，称为__clone.
 
### 引用的作用 
 如果程序比较大,引用同一个对象的变量比较多,并且希望用完该对象后手工清除它,个人建议用 "&" 方式,然后用$var=null的方式清除. 其它时候还是用php5的默认方式吧. 另外, php5中对于大数组的传递,建议用 "&" 方式, 毕竟节省内存空间使用。

### 取消引用 
- 当你 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了

### EXAMPLE
```php

$array = [1, 2, 3];
echo implode(',', $array), "\n";

foreach ($array as &$value) {}    // 通过引用遍历
echo implode(',', $array), "\n";

foreach ($array as $value) {}     // 通过赋值遍历
echo implode(',', $array), "\n";

//1,2,3
//1,2,3
//1,2,2
```

>你要记住 foreach 并不会产生一个块级作用域。因此，在上面例子中 $value 是一个全局引用变量。在 foreach 遍历中，每一次迭代都会形成一个对 $arr 下一个元素的引用。当遍历结束后， $value 会引用 $arr 的最后一个元素，并保留在作用域中

>在完成第一个 foreach 遍历后， $array 并没有改变，但是像上述解释的那样， $value 留下了一个对 $array 最后一个元素的危险的引用（因为 foreach 通过引用获得 $value ）

>这导致当运行到第二个 foreach ，这个 "奇怪的东西" 发生了。当 $value 通过赋值获得， foreach 按顺序复制每个 $array 的元素到 $value 时，第二个 foreach 里面的细节是这样的

- 第一步：复制 $array[0] （也就是 1 ）到 $value （$value 其实是 $array 最后一个元素的引用，即 $array[2]），所以 $array[2] 现在等于 1。所以 $array 现在包含 [1, 2, 1]
- 第二步：复制 $array[1]（也就是 2 ）到 $value （ $array[2] 的引用），所以 $array[2] 现在等于 2。所以 $array 现在包含 [1, 2, 2]
- 第三步：复制 $array[2]（现在等于 2 ） 到 $value （ $array[2] 的引用），所以 $array[2] 现在等于 2 。所以 $array 现在包含 [1, 2, 2]


